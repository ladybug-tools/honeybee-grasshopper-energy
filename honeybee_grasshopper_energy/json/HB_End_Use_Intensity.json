{
  "version": "1.3.1", 
  "nickname": "EUI", 
  "outputs": [
    [
      {
        "access": "None", 
        "name": "eui", 
        "description": "The total end use intensity result from the simulation. Specifically,\nthis is the sum of all electricity, fuel, district heating/cooling,\netc. divided by the gross floor area (including both conditioned\nand unconditioned spaces). The value will be in kWh/m2 if ip_\nis False or None and kBtu/ft2 if True.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "eui_end_use", 
        "description": "The end use intensity result from the simulation, broken down by each\nend use. These values coorespond to the end_uses output below. Values\nwill be in kWh/m2 if ip_ is False or None and kBtu/ft2 if True.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "end_uses", 
        "description": "A list of text for each of the end uses in the simulation (Heating,\nCooling, etc.). Thes outputs coorespond to the eui_end_use\noutput above.", 
        "type": null, 
        "default": null
      }, 
      {
        "access": "None", 
        "name": "gross_floor", 
        "description": "The total gross floor area of the energy model. This can be used\nto compute the total energy use from the intensity values above or\nit can be used to help with other result post-processing. The value\nwill be in m2 if ip_ is False or None and ft2 if True.", 
        "type": null, 
        "default": null
      }
    ]
  ], 
  "inputs": [
    {
      "access": "list", 
      "name": "_sql", 
      "description": "The file path of the SQL result file that has been generated from\nan energy simulation. This can also be a list of EnergyPlus files\nin which case, EUI will be computed across all files.", 
      "type": "string", 
      "default": null
    }, 
    {
      "access": "item", 
      "name": "ip_", 
      "description": "Boolean to note whether the EUI should be in SI (kWh/m2) or IP\n(kBtu/ft2) units. (Default: False).", 
      "type": "bool", 
      "default": null
    }
  ], 
  "subcategory": "6 :: Result", 
  "code": "\nimport os\nimport subprocess\nimport json\n\nfrom collections import OrderedDict\n\ntry:\n    from ladybug.sql import SQLiteResult\n    from ladybug.datatype.area import Area\n    from ladybug.datatype.energyintensity import EnergyIntensity\n    from ladybug.datatype.energy import Energy\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug:\\n\\t{}'.format(e))\n\ntry:\n    from honeybee.config import folders\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import honeybee:\\n\\t{}'.format(e))\n\ntry:\n    from ladybug_{{cad}}.{{plugin}} import all_required_inputs\nexcept ImportError as e:\n    raise ImportError('\\nFailed to import ladybug_{{cad}}:\\n\\t{}'.format(e))\n\n\n# Use the SQLiteResult class to parse the result files directly on Windows.\ndef get_results_windows(sql_files):\n    # set initial values that will be computed based on results\n    total_floor_area, total_energy = 0, 0\n    end_uses = OrderedDict()\n\n    # loop through the sql files in the directory and add the energy use\n    for result_file in sql_files:\n        # parse the SQL file\n        sql_obj = SQLiteResult(result_file)\n        # get the total floor area of the model\n        area_dict = sql_obj.tabular_data_by_name('Building Area')\n        areas = tuple(area_dict.values())\n        total_floor_area += areas[0][0]\n        # get the energy use\n        eui_dict = sql_obj.tabular_data_by_name('End Uses By Subcategory')\n        for catgory, vals in eui_dict.items():\n            total_use = sum([val for val in vals[:12]])\n            if total_use != 0:\n                total_energy += total_use\n                cat, sub_cat = catgory.split(':')\n                eu_cat = cat if sub_cat == 'General' or sub_cat == 'Other' else sub_cat\n                try:\n                    end_uses[eu_cat] += total_use\n                except KeyError:\n                    end_uses[eu_cat] = total_use\n\n    # assemble all of the results into a final dictionary\n    eui = round(total_energy / total_floor_area, 3)\n    gross_floor = round(total_floor_area, 3)\n    end_use_pairs = OrderedDict(\n        [(key, round(val / total_floor_area, 3)) for key, val in end_uses.items()]\n    )\n    return eui, gross_floor, end_use_pairs\n\n# The SQLite3 module doesn't work in IronPython on Mac, so we must make a call\n# to the Honeybee CLI (which runs on CPython) to get the results.\ndef get_results_mac(sql_files):\n    cmds = [folders.python_exe_path, '-m', 'honeybee_energy', 'result',\n            'energy-use-intensity']\n    cmds.extend(sql_files)\n    process = subprocess.Popen(cmds, stdout=subprocess.PIPE)\n    stdout = process.communicate()\n    results = json.loads(stdout[0], object_pairs_hook=OrderedDict)\n    return results['eui'], results['total_floor_area'], results['end_uses']\n\n\nif all_required_inputs(ghenv.Component):\n    # ensure that _sql is a list rather than a single string\n    if isinstance(_sql, basestring):\n        _sql = [_sql]\n    \n\t# get the results\n    get_results = get_results_windows if os.name == 'nt' else get_results_mac\n    eui, gross_floor, end_use_pairs = get_results(_sql)\n        \n    # create separate lists for end use values and labels\n    eui_end_use = end_use_pairs.values()\n    end_uses = [use.replace('_', ' ').title() for use in end_use_pairs.keys()]\n\n    # convert data to IP if requested\n    if ip_:\n        eui_typ, a_typ, e_typ = EnergyIntensity(), Area(), Energy()\n        eui = round(eui_typ.to_ip([eui], 'kWh/m2')[0][0], 3)\n        gross_floor = round(a_typ.to_ip([gross_floor], 'm2')[0][0], 3)\n        eui_end_use = [round(eui_typ.to_ip([val], 'kWh/m2')[0][0], 3)\n                       for val in eui_end_use]\n", 
  "category": "HB-Energy", 
  "name": "HB End Use Intensity", 
  "description": "Get information about end use intensity from an EnergyPlus SQL file.\n-"
}